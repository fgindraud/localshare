#ifndef DISCOVERY_H
#define DISCOVERY_H

#include <QtNetwork>

#include "settings.h"
#include "localshare.h"

#include <dns_sd.h>

namespace Discovery {

class Service;
class Browser;

/*
 * Peer information
 */
struct Peer {
	QString username;
	QHostAddress address;
	quint16 port;
};

/*
 * Service announce class
 */
class Service : public QObject {
	Q_OBJECT

	/* Registers at construction, and unregister at destruction.
	 * Name of service is limited to kDNSServiceMaxServiceName utf8 bytes (64B including '\0'
	 * currently). Longer names will be truncated by the library, so do nothing about that. The actual
	 * registered name will be provided by the callback and given to the app through the registered
	 * signal.
	 *
	 * Errors are critical.
	 */
private:
	QString username;
	DNSServiceRef service{nullptr};

signals:
	void registered (QString name);

public:
	Service (const QString & name, const QString & service_name, quint16 tcp_port,
	         QObject * parent = nullptr)
	    : QObject (parent), username (name) {
		// Start registration
		auto err = DNSServiceRegister (
		    &service, 0 /* flags */, 0 /* any interface */, qUtf8Printable (username),
		    qUtf8Printable (service_name), nullptr /* default domain */, nullptr /* default hostname */,
		    qToBigEndian (tcp_port) /* port in NBO */, 0, nullptr /* text len and text */,
		    register_callback, this /* context */);
		if (err == kDNSServiceErr_NoError) {
			int fd = DNSServiceRefSockFD (service);
			if (fd != -1) {
				auto service_notifier = new QSocketNotifier (fd, QSocketNotifier::Read, this);
				connect (service_notifier, SIGNAL (activated (int) ), this,
				         SLOT (service_socket_has_data ()));
			} else {
				qCritical () << "Service: unable to get socket";
			}
		} else {
			qCritical () << "Service: unable to register:" << err;
		}
	}

	~Service () {
		if (service != nullptr)
			DNSServiceRefDeallocate (service);
	}

private:
	static void register_callback (DNSServiceRef, DNSServiceFlags, DNSServiceErrorType error_code,
	                               const char * name, const char * service_type, const char * domain,
	                               void * context) {
		if (error_code == kDNSServiceErr_NoError) {
			auto c = static_cast<Service *> (context);
			c->username = name;
			emit c->registered (c->username);
			qDebug () << "Service: registered" << c->username << service_type << domain;
		} else {
			qCritical () << "Service: unable to register:" << error_code;
		}
	}

private slots:
	void service_socket_has_data (void) {
		auto err = DNSServiceProcessResult (service);
		if (err != kDNSServiceErr_NoError)
			qCritical () << "Service: error:" << err;
	}
};

// Name resolver query (internal)
class Resolver : public QObject {
	Q_OBJECT
	/* Temporary structure use to represent a resolve query.
	 * Resolve query : from DNS_SD service id to address, name, port.
	 *
	 * Instances of this class are generated by a parent Browser.
	 * They are child of the browser, and will delete themselves after use (or error), or be deleted
	 * by the Browser if it dies.
	 * At success, they trigger a slot in the Browser.
	 *
	 * Steps:
	 * - Starting resolve connection.
	 * - Resolve callback is called: start Hostname lookup
	 * - Hostname lookup finished: choose address, emit resulting peer.
	 *
	 * Errors make the query fail, but do not abort.
	 */
private:
	DNSServiceRef resolver{nullptr};
	int host_lookup_id{-1}; // Temporarily != -1 when hostname lookup is in flight
	Peer peer_info;

signals:
	void peer_complete (Peer);

public:
	Resolver (QObject * browser, uint32_t interface_index, const char * name, const char * regtype,
	          const char * domain)
	    : QObject (browser) {
		peer_info.username = name;
		// Prepare output signal
		connect (this, SIGNAL (peer_complete (Peer)), browser, SLOT (resolved_peer_added (Peer)));
		// Start resolve
		auto err = DNSServiceResolve (&resolver, 0 /* flags */, interface_index, name, regtype, domain,
		                              resolver_callback, this /* context */);
		if (err == kDNSServiceErr_NoError) {
			int fd = DNSServiceRefSockFD (resolver);
			if (fd != -1) {
				auto resolver_notifier = new QSocketNotifier (fd, QSocketNotifier::Read, this);
				connect (resolver_notifier, SIGNAL (activated (int) ), this,
				         SLOT (resolver_socket_has_data ()));
			} else {
				qWarning () << "Resolver: unable to get socket";
				deleteLater ();
			}
		} else {
			qWarning () << "Resolver: unable to resolve:" << err;
			deleteLater ();
		}
	}
	~Resolver () {
		if (host_lookup_id != -1)
			QHostInfo::abortHostLookup (host_lookup_id);
		if (resolver != nullptr)
			DNSServiceRefDeallocate (resolver);
	}

private:
	static void resolver_callback (DNSServiceRef, DNSServiceFlags, uint32_t /* interface */,
	                               DNSServiceErrorType error_code, const char * /* fullname */,
	                               const char * host, uint16_t port, uint16_t /* txt len */,
	                               const unsigned char * /* txt record */, void * context) {
		auto c = static_cast<Resolver *> (context);
		if (error_code == kDNSServiceErr_NoError) {
			c->peer_info.port = qFromBigEndian (port);
			c->host_lookup_id = QHostInfo::lookupHost (host, c, SLOT (host_lookup_finished (QHostInfo)));

			qDebug () << "Resolver: found" << host << c->peer_info.port;
		} else {
			qWarning () << "Resolver: unable to resolve:" << error_code;
			c->deleteLater ();
		}
	}

private slots:
	void resolver_socket_has_data (void) {
		auto err = DNSServiceProcessResult (resolver);
		if (err != kDNSServiceErr_NoError) {
			qWarning () << "Resolver: error:" << err;
			deleteLater ();
		}
	}

	void host_lookup_finished (QHostInfo host_info) {
		host_lookup_id = -1; // host request has finished
		if (host_info.error () == QHostInfo::NoError) {
			const auto addr_list = host_info.addresses ();
			// TODO choose an address
			qDebug () << addr_list;
			emit peer_complete (peer_info);
		} else {
			qWarning () << "Resolver: unable to resolve host" << host_info.hostName ()
			            << host_info.errorString ();
		}
		deleteLater ();
	}
};

/*
 * Service browser
 */
class Browser : public QObject {
	Q_OBJECT

	/* Browser object.
	 * Starts browsing at creation, stops at destruction.
	 * Emits added/removed signals to indicate changes to peer list.
	 *
	 * Errors are critical.
	 */
private:
	QList<Peer> discovered_peers;
	using PeerRef = decltype (discovered_peers)::iterator;

	DNSServiceRef browser{nullptr};

signals:
	void added (Peer);
	void removed (Peer);

public:
	Browser (const QString & service_name, QObject * parent = nullptr) : QObject (parent) {
		auto err =
		    DNSServiceBrowse (&browser, 0 /* flags */, 0 /* interface */, qUtf8Printable (service_name),
		                      nullptr /* default domain */, browser_callback, this /* context */);
		if (err == kDNSServiceErr_NoError) {
			int fd = DNSServiceRefSockFD (browser);
			if (fd != -1) {
				auto browser_notifier = new QSocketNotifier (fd, QSocketNotifier::Read, this);
				connect (browser_notifier, SIGNAL (activated (int) ), this,
				         SLOT (browser_socket_has_data ()));
			} else {
				qCritical () << "Browser: unable to get socket";
			}
		} else {
			qCritical () << "Browser: unable to browse:" << err;
		}
	}
	~Browser () {
		if (browser != nullptr)
			DNSServiceRefDeallocate (browser);
	}

private:
	static void browser_callback (DNSServiceRef, DNSServiceFlags flags, uint32_t interface_index,
	                              DNSServiceErrorType error_code, const char * name,
	                              const char * service_name, const char * domain, void * context) {
		if (error_code == kDNSServiceErr_NoError) {
			auto c = static_cast<Browser *> (context);
			if (flags & kDNSServiceFlagsAdd) {
				// Peer is added
				qDebug () << "Browser: found" << name << service_name << domain;
				new Resolver (c, interface_index, name, service_name, domain); // Resolve it
			} else {
				// Peer is removed
				auto peer_ref = c->discovered_by_name (name);
				if (peer_ref != c->discovered_peers.end ()) {
					emit c->removed (*peer_ref);
					c->discovered_peers.erase (peer_ref);
				} else {
					qWarning () << "Browser: remove: peer does not exists:" << name;
				}
			}
		} else {
			qCritical () << "Browser: unable to browse:" << error_code;
		}
	}

	PeerRef discovered_by_name (const QString & username) {
		for (auto it = discovered_peers.begin (); it != discovered_peers.end (); ++it)
			if (it->username == username)
				return it;
		return discovered_peers.end ();
	}

private slots:
	void browser_socket_has_data (void) {
		auto err = DNSServiceProcessResult (browser);
		if (err != kDNSServiceErr_NoError)
			qCritical () << "Browser: error:" << err;
	}

	void resolved_peer_added (Peer peer) {
		qDebug () << "Browser: new_peer" << peer.username << peer.address << peer.port;

		auto peer_ref = discovered_by_name (peer.username);
		if (peer_ref == discovered_peers.end ()) {
			discovered_peers.append (peer);
			emit added (peer);
		} else {
			qWarning () << "Browser: add: peer already exists:" << peer.username;
		}
	}
};
}

Q_DECLARE_METATYPE (Discovery::Peer);

#endif
